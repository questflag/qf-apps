using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using MediatR;
using QuestFlag.Infrastructure.Domain.Entities;
using QuestFlag.Infrastructure.Domain.Enums;
using QuestFlag.Infrastructure.Domain.Events;
using QuestFlag.Infrastructure.Domain.Interfaces;

namespace QuestFlag.Infrastructure.Application.Features.Uploads.Commands;

public record UploadFileCommand(
    Guid TenantId,
    Guid UserId,
    string TenantSlug,
    string OriginalFileName,
    string Category,
    string TaskName,
    Stream FileStream,
    long SizeInBytes,
    string ContentType,
    string[] Tags,
    System.Collections.Generic.Dictionary<string, string> ExtraData) : IRequest<Guid>;

public class UploadFileCommandHandler : IRequestHandler<UploadFileCommand, Guid>
{
    private readonly IUploadRepository _repository;
    private readonly IStorageService _storageService;
    private readonly IUploadEventPublisher _eventPublisher;

    public UploadFileCommandHandler(
        IUploadRepository repository,
        IStorageService storageService,
        IUploadEventPublisher eventPublisher)
    {
        _repository = repository;
        _storageService = storageService;
        _eventPublisher = eventPublisher;
    }

    public async Task<Guid> Handle(UploadFileCommand request, CancellationToken cancellationToken)
    {
        // 1. Generate keys
        var recordId = Guid.NewGuid();
        var safeFileName = Path.GetFileName(request.OriginalFileName);
        
        // Prefix generated by system: {tenantId}-{userId}-{taskName}-{OriginalFileName}
        var storedFileName = $"{request.TenantId}-{request.UserId}-{request.TaskName}-{safeFileName}";
        
        // One bucket per tenant
        var bucketName = request.TenantSlug.ToLowerInvariant(); 
        
        // Object Key: {category}/{taskName}/{StoredFileName}
        var objectKey = $"{request.Category}/{request.TaskName}/{storedFileName}";

        // 2. Create tracking record (Status = Uploading)
        var record = new UploadRecord
        {
            Id = recordId,
            TenantId = request.TenantId,
            UserId = request.UserId,
            OriginalFileName = request.OriginalFileName,
            StoredFileName = storedFileName,
            BucketName = bucketName,
            ObjectKey = objectKey,
            TaskName = request.TaskName,
            Category = request.Category,
            SizeInBytes = request.SizeInBytes,
            Tags = request.Tags ?? Array.Empty<string>(),
            ExtraData = request.ExtraData ?? new(),
            Status = UploadStatus.Uploading,
            CreatedAtUtc = DateTime.UtcNow
        };

        await _repository.AddAsync(record, cancellationToken);

        try
        {
            // 3. Upload to target storage (MinIO/GCP wrapper)
            await _storageService.UploadStreamAsync(
                bucketName, 
                objectKey, 
                request.FileStream, 
                request.ContentType, 
                cancellationToken);

            // 4. Mark success
            record.Status = UploadStatus.Completed;
            record.CompletedAtUtc = DateTime.UtcNow;
            await _repository.UpdateAsync(record, cancellationToken);

            // 5. Fire Kafka Event
            var uploadEvent = new UploadCompletedEvent(
                record.Id, 
                record.TenantId, 
                record.UserId, 
                record.TaskName, 
                record.ObjectKey, 
                record.SizeInBytes,
                record.CompletedAtUtc.Value);
                
            await _eventPublisher.PublishUploadCompletedAsync(uploadEvent, cancellationToken);
        }
        catch (Exception ex)
        {
            // 6. Handle failure
            record.Status = UploadStatus.Failed;
            record.ErrorMessage = ex.Message;
            await _repository.UpdateAsync(record, cancellationToken);
            throw; // Rethrow to let the API return 500
        }

        return record.Id;
    }
}
